# Алгоритм по шагам для функции расчета времени прибытия (Calculating Time)

## Шаг 1. Начало.

**Входные данные:**
- `int tripId` – идентификатор рейса, для которого рассчитывается время прибытия;
- `double averageSpeed` – средняя скорость транспорта в км/ч;

**Выходные данные:**
- Расписание времени прибытия для всех остановок маршрута рейса сохранено в объекте `Trip` или выведено сообщение об ошибке;

## Шаг 2. Проверить корректность входных данных.

Проверить условие: `averageSpeed <= 0`.

- Если условие истинно (скорость некорректна):
  - Сгенерировать исключение `InputException` с сообщением "Средняя скорость должна быть положительной"
  - Перейти к обработке исключений (Шаг 15)
- Если условие ложно (скорость корректа):
  - Перейти к Шагу 3

## Шаг 3. Получить список всех рейсов системы.

Вызвать метод `system->getTrips()` для получения списка всех рейсов и сохранить результат в `const auto& trips`.

## Шаг 4. Найти рейс по идентификатору.

**Шаг 4.1. Начать поиск рейса.**

Использовать алгоритм `std::find_if` для поиска рейса с заданным `tripId`:

```cpp
auto tripIt = std::find_if(trips.begin(), trips.end(),
                          [tripId](const auto& t) { return t->getTripId() == tripId; });
```

**Шаг 4.2. Проверить результат поиска.**

Проверить условие: `tripIt == trips.end()`.

- Если условие истинно (рейс не найден):
  - Сгенерировать исключение `ContainerException` с сообщением "Рейс с ID [tripId] не найден"
  - Перейти к обработке исключений (Шаг 15)
- Если условие ложно (рейс найден):
  - Перейти к Шагу 5

## Шаг 5. Получить информацию о рейсе.

**Шаг 5.1. Получить указатель на рейс.**

Разыменовать итератор: `auto trip = *tripIt` – получить умный указатель на найденный рейс.

**Шаг 5.2. Получить маршрут рейса.**

Вызвать метод `trip->getRoute()` для получения указателя на маршрут рейса и сохранить в `const auto& route`.

**Шаг 5.3. Получить список остановок маршрута.**

Вызвать метод `route->getAllStops()` для получения списка остановок маршрута и сохранить результат в `const auto& stopsList`.

## Шаг 6. Проверить наличие остановок в маршруте.

Проверить условие: `stopsList.empty()`.

- Если условие истинно (список остановок пуст):
  - Сгенерировать исключение `ContainerException` с сообщением "Маршрут не содержит остановок"
  - Перейти к обработке исключений (Шаг 15)
- Если условие ложно (есть остановки):
  - Перейти к Шагу 7

## Шаг 7. Инициализировать переменные для расчета.

**Шаг 7.1. Получить время отправления с начальной остановки.**

Вызвать метод `trip->getStartTime()` для получения времени отправления и сохранить в `Time currentTime`.

**Шаг 7.2. Установить время прибытия на начальную остановку.**

Вызвать метод `trip->setArrivalTime(stopsList[0], currentTime)` для установки времени прибытия на первую остановку равным времени отправления.

**Шаг 7.3. Инициализировать константы расчета.**

Объявить и инициализировать константы:
- `const double distanceBetweenStops = 1.5` – расстояние между остановками в километрах (константа);
- `const int stopTime = 1` – время стоянки на остановке в минутах (константа);

**Примечание:** В идеальной реализации эти значения должны вычисляться динамически на основе реальных данных об остановках.

## Шаг 8. Начать цикл расчета времени для всех остановок.

**Начало цикла:** `for (size_t i = 1; i < stopsList.size(); ++i)`

Для каждой остановки с индексом `i` от 1 до `stopsList.size() - 1` выполнить Шаги 9-13.

## Шаг 9. Рассчитать время в пути между остановками.

**Шаг 9.1. Рассчитать время в пути в минутах.**

Вычислить время в пути по формуле:
```
double travelTimeMinutes = (distanceBetweenStops / averageSpeed) * 60
```

Где:
- `distanceBetweenStops` – расстояние между остановками в километрах;
- `averageSpeed` – средняя скорость транспорта в км/ч;
- Результат умножается на 60 для перевода часов в минуты;

**Шаг 9.2. Округлить время в пути до целых минут.**

При вычислении времени прибытия округление выполняется автоматически при преобразовании:
```
Time arrivalTime = currentTime + static_cast<int>(travelTimeMinutes + 0.5)
```

Где `+ 0.5` обеспечивает математическое округление до ближайшего целого.

## Шаг 10. Определить время прибытия на текущую остановку.

**Шаг 10.1. Вычислить время прибытия.**

Вычислить: `Time arrivalTime = currentTime + static_cast<int>(travelTimeMinutes + 0.5)` – время прибытия равно текущему времени плюс время в пути (округленное до целых минут).

**Шаг 10.2. Записать время прибытия для остановки.**

Вызвать метод `trip->setArrivalTime(stopsList[i], arrivalTime)` для сохранения времени прибытия на остановку с индексом `i` в расписании рейса.

## Шаг 11. Определить время отправления с текущей остановки.

**Шаг 11.1. Вычислить время отправления.**

Вычислить: `currentTime = arrivalTime + stopTime` – время отправления равно времени прибытия плюс время стоянки на остановке.

**Примечание:** В текущей реализации время отправления не сохраняется отдельно в расписании, оно используется только для расчета времени прибытия на следующую остановку.

## Шаг 12. Обновить текущее время для следующей итерации.

Присвоить `currentTime` = `arrivalTime + stopTime` (уже выполнено в Шаге 11.1).

Текущее время теперь равно времени отправления с текущей остановки и будет использовано для расчета времени прибытия на следующую остановку.

## Шаг 13. Завершить итерацию цикла.

Увеличить счетчик цикла: `i = i + 1` (выполняется автоматически в заголовке цикла `for`).

**Проверить условие продолжения цикла:** `i < stopsList.size()`.

- Если условие истинно (есть еще остановки):
  - Вернуться к Шагу 9 (продолжить расчет для следующей остановки)
- Если условие ложно (все остановки обработаны):
  - Перейти к Шагу 14

## Шаг 14. Завершить расчет времени прибытия.

**Шаг 14.1. Расписание сохранено.**

Все времена прибытия для остановок маршрута сохранены в объекте `Trip` через вызовы метода `setArrivalTime()`.

**Шаг 14.2. Вернуть управление.**

Завершить выполнение функции `calculateArrivalTimes()`.

## Шаг 15. Конец алгоритма.

## Шаг 16. Обработка исключений.

**Если возникло исключение в процессе выполнения:**

**Шаг 16.1. Перехватить исключение.**

Исключения перехватываются в вызывающем коде (например, в функции `adminCalculateTime` в `ui.cpp`).

**Шаг 16.2. Вывести сообщение об ошибке.**

Вывести сообщение: "Ошибка: " + `e.what()` + "\n".

**Шаг 16.3. Завершить выполнение функции.**

Вернуть управление вызывающему коду.

