# Алгоритм по шагам для функции calculateArrivalTimes (Calculating Time)

## Шаг 1. Начало.

**Входные данные:**
- `int tripId` – идентификатор рейса, для которого рассчитывается время прибытия;
- `double averageSpeed` – средняя скорость транспорта (км/ч), используемая для расчета времени в пути;

**Выходные данные:**
- Обновленное расписание рейса с рассчитанными временами прибытия на каждую остановку;

## Шаг 2. Проверить корректность входных данных.

Проверить условие: `averageSpeed <= 0`.

**Если условие истинно (скорость некорректна):**
- Сгенерировать исключение `InputException` с сообщением "Средняя скорость должна быть положительной"
- Завершить выполнение функции

**Если условие ложно (скорость корректна):**
- Перейти к Шагу 3

## Шаг 3. Получить список всех рейсов системы.

Вызвать метод: `const auto& trips = system->getTrips()` для получения ссылки на список всех рейсов системы.

## Шаг 4. Найти рейс по идентификатору.

**Начало поиска:**

Использовать алгоритм `std::find_if()` для поиска рейса:
- `auto tripIt = std::find_if(trips.begin(), trips.end(), [tripId](const auto& t) { return t->getTripId() == tripId; })`

**Проверить результат поиска:**

Проверить условие: `tripIt == trips.end()`.

**Если условие истинно (рейс не найден):**
- Сгенерировать исключение `ContainerException` с сообщением "Рейс с ID " + std::to_string(tripId) + " не найден"
- Завершить выполнение функции

**Если условие ложно (рейс найден):**
- Перейти к Шагу 5

## Шаг 5. Получить информацию о рейсе.

Разыменовать итератор: `auto trip = *tripIt` для получения умного указателя на рейс.

## Шаг 6. Получить маршрут рейса.

Вызвать метод: `const auto& route = trip->getRoute()` для получения указателя на маршрут рейса.

## Шаг 7. Получить список остановок маршрута.

Вызвать метод: `const auto& stopsList = route->getAllStops()` для получения списка всех остановок маршрута.

## Шаг 8. Проверить наличие остановок в маршруте.

Проверить условие: `stopsList.empty()`.

**Если условие истинно (список остановок пуст):**
- Сгенерировать исключение `ContainerException` с сообщением "Маршрут не содержит остановок"
- Завершить выполнение функции

**Если условие ложно (есть остановки):**
- Перейти к Шагу 9

## Шаг 9. Получить время отправления с начальной остановки.

Вызвать метод: `Time currentTime = trip->getStartTime()` для получения времени отправления рейса.

## Шаг 10. Установить время прибытия на начальную остановку.

Вызвать метод: `trip->setArrivalTime(stopsList[0], currentTime)` для установки времени прибытия на первую остановку (время прибытия равно времени отправления).

## Шаг 11. Инициализировать константы для расчета.

Объявить и инициализировать константы:
- `const double distanceBetweenStops = 1.5` – расстояние между остановками в километрах (константа);
- `const int stopTime = 1` – время стоянки на остановке в минутах (константа);

**Примечание:** В идеальной реализации эти значения должны вычисляться динамически на основе реальных данных об остановках.

## Шаг 12. Начать цикл расчета времени для всех остановок.

**Начало цикла:** `for (size_t i = 1; i < stopsList.size(); ++i)`

Для каждой остановки с индексом `i` от 1 до последней остановки выполнить шаги 13-17.

## Шаг 13. Рассчитать время в пути между остановками.

Вычислить время в пути в минутах:
- `double travelTimeMinutes = (distanceBetweenStops / averageSpeed) * 60`

**Формула:** время = (расстояние / скорость) * 60 (для перевода часов в минуты)

## Шаг 14. Рассчитать время прибытия на следующую остановку.

Вычислить время прибытия:
- `Time arrivalTime = currentTime + static_cast<int>(travelTimeMinutes + 0.5)`

**Примечание:** Использование `static_cast<int>(travelTimeMinutes + 0.5)` обеспечивает округление до ближайшего целого числа минут.

## Шаг 15. Записать время прибытия для остановки.

Вызвать метод: `trip->setArrivalTime(stopsList[i], arrivalTime)` для сохранения времени прибытия на остановку с индексом `i`.

## Шаг 16. Рассчитать время отправления со следующей остановки.

Вычислить время отправления:
- `currentTime = arrivalTime + stopTime`

**Формула:** время отправления = время прибытия + время стоянки

**Примечание:** В текущей реализации время отправления не сохраняется отдельно, а используется как `currentTime` для расчета следующей остановки.

## Шаг 17. Завершить цикл по остановкам.

Если `i < stopsList.size() - 1`, вернуться к Шагу 12 для обработки следующей остановки.

Если `i == stopsList.size() - 1` (обработана последняя остановка), перейти к Шагу 18.

## Шаг 18. Завершить расчет времени.

Все времена прибытия рассчитаны и сохранены в расписании рейса.

**Примечание:** В текущей реализации метод `calculateArrivalTimes` не вызывает явный метод сохранения расписания, так как времена сохраняются непосредственно в объекте `Trip` через метод `setArrivalTime()`.

## Шаг 19. Конец алгоритма.

Завершить выполнение функции. Расписание рейса обновлено с рассчитанными временами прибытия на все остановки.




