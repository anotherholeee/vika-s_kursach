# Алгоритмы для блок-схем: New Route и Calculating Time

## 1. Алгоритм создания маршрута (New Route)

### Начало
```
НАЧАЛО
```

### Шаг 1: Ввод данных
```
1. ВВОД: номер маршрута (number)
   ЕСЛИ ввод некорректный:
      ВЫВОД: "Ошибка: Неверный формат ввода"
      ПЕРЕХОД К: КОНЕЦ
```

### Шаг 2: Ввод типа транспорта
```
2. ВВОД: тип транспорта (vehicleType)
   (Автобус/Трамвай/Троллейбус)
```

### Шаг 3: Ввод остановок
```
3. ИНИЦИАЛИЗАЦИЯ: stops = пустой список
4. ЦИКЛ: ПОКА (true)
   4.1. ВВОД: название остановки (stop)
   4.2. ЕСЛИ stop == "конец":
          ВЫХОД ИЗ ЦИКЛА
   4.3. ИНАЧЕ:
          ДОБАВИТЬ stop в stops
   КОНЕЦ ЦИКЛА
```

### Шаг 4: Создание объекта маршрута
```
5. ПОПЫТКА:
   5.1. СОЗДАТЬ объект Route(number, vehicleType, stops)
   5.2. В конструкторе Route:
        ЕСЛИ stops пустой:
           ВЫБРОСИТЬ исключение: "Маршрут не может быть пустым"
        ИНАЧЕ:
           startStop = stops[0]
           endStop = stops[последний]
   ИСКЛЮЧЕНИЕ:
      ВЫВОД: "Ошибка: " + сообщение об ошибке
      ПЕРЕХОД К: КОНЕЦ
```

### Шаг 5: Проверка уникальности номера
```
6. ВЫЗОВ: system.addRoute(route)
   6.1. ЦИКЛ: ДЛЯ каждого existingRoute в routes
        ЕСЛИ existingRoute->getNumber() == route->getNumber():
           ВЫБРОСИТЬ исключение: "Маршрут с номером X уже существует"
        КОНЕЦ ЦИКЛА
```

### Шаг 6: Выполнение команды добавления
```
   6.2. СОЗДАТЬ команду: AddRouteCommand(system, route)
   6.3. ВЫПОЛНИТЬ команду через commandHistory.executeCommand()
        В методе execute():
           ВЫЗОВ: system->addRouteDirect(route)
```

### Шаг 7: Прямое добавление в систему
```
   6.4. В методе addRouteDirect():
        ДОБАВИТЬ route в список routes
```

### Шаг 8: Завершение
```
7. ВЫВОД: "Маршрут успешно добавлен!"
8. КОНЕЦ
```

---

## 2. Алгоритм расчета времени прибытия (Calculating Time)

### Начало
```
НАЧАЛО
```

### Шаг 1: Ввод данных
```
1. ВВОД: ID рейса (tripId)
2. ВВОД: средняя скорость (averageSpeed, км/ч)
```

### Шаг 2: Проверка скорости
```
3. ВЫЗОВ: system.calculateArrivalTimes(tripId, averageSpeed)
   3.1. ЕСЛИ averageSpeed <= 0:
          ВЫБРОСИТЬ исключение: "Средняя скорость должна быть положительной"
          ВЫВОД: "Ошибка: " + сообщение
          ПЕРЕХОД К: КОНЕЦ
```

### Шаг 3: Поиск рейса
```
   3.2. ПОЛУЧИТЬ список рейсов: trips = system->getTrips()
   3.3. НАЙТИ рейс: tripIt = найти в trips, где trip->getTripId() == tripId
   3.4. ЕСЛИ рейс НЕ найден (tripIt == trips.end()):
          ВЫБРОСИТЬ исключение: "Рейс с ID X не найден"
          ВЫВОД: "Ошибка: " + сообщение
          ПЕРЕХОД К: КОНЕЦ
```

### Шаг 4: Получение данных маршрута
```
   3.5. ПОЛУЧИТЬ рейс: trip = *tripIt
   3.6. ПОЛУЧИТЬ маршрут: route = trip->getRoute()
   3.7. ПОЛУЧИТЬ список остановок: stopsList = route->getAllStops()
   3.8. ЕСЛИ stopsList пустой:
          ВЫБРОСИТЬ исключение: "Маршрут не содержит остановок"
          ВЫВОД: "Ошибка: " + сообщение
          ПЕРЕХОД К: КОНЕЦ
```

### Шаг 5: Инициализация времени
```
   3.9. УСТАНОВИТЬ константы:
        distanceBetweenStops = 1.5 км
        stopTime = 1 минута
   3.10. ПОЛУЧИТЬ время отправления: currentTime = trip->getStartTime()
   3.11. УСТАНОВИТЬ время прибытия на первую остановку:
         trip->setArrivalTime(stopsList[0], currentTime)
```

### Шаг 6: Цикл расчета времени для всех остановок
```
   3.12. ЦИКЛ: ДЛЯ i от 1 до (stopsList.size() - 1)
         (i - индекс текущей остановки)
         
         3.12.1. РАССЧИТАТЬ время в пути:
                 travelTimeMinutes = (distanceBetweenStops / averageSpeed) * 60
                 (перевод из часов в минуты)
         
         3.12.2. РАССЧИТАТЬ время прибытия на остановку i:
                 arrivalTime = currentTime + округлить(travelTimeMinutes)
         
         3.12.3. СОХРАНИТЬ время прибытия:
                 trip->setArrivalTime(stopsList[i], arrivalTime)
         
         3.12.4. РАССЧИТАТЬ время отправления с остановки i:
                 currentTime = arrivalTime + stopTime
         
       КОНЕЦ ЦИКЛА
```

### Шаг 7: Завершение
```
4. ВЫВОД: "Время прибытия рассчитано для всех остановок"
5. КОНЕЦ
```

---

## Структура блок-схем

### Для New Route:
- **Блоки ввода**: Ввод номера, типа транспорта, остановок
- **Блоки проверки**: Проверка корректности ввода, проверка уникальности номера
- **Блоки обработки**: Создание объекта Route, добавление в систему
- **Блоки вывода**: Сообщения об успехе/ошибке
- **Цикл**: Ввод остановок до ввода "конец"
- **Условия**: Проверка корректности данных, проверка уникальности

### Для Calculating Time:
- **Блоки ввода**: Ввод ID рейса, средней скорости
- **Блоки проверки**: Проверка скорости > 0, проверка существования рейса, проверка наличия остановок
- **Блоки обработки**: Поиск рейса, получение маршрута и остановок
- **Блоки расчета**: Расчет времени в пути, времени прибытия, времени отправления
- **Цикл**: Расчет времени для каждой остановки (от второй до последней)
- **Условия**: Проверки корректности входных данных

---

## Условные обозначения для блок-схем

- **Овал** - Начало/Конец
- **Параллелограмм** - Ввод/Вывод данных
- **Прямоугольник** - Процесс (вычисления, присваивания)
- **Ромб** - Условие (ветвление)
- **Шестиугольник** - Цикл (начало цикла)
- **Стрелки** - Направление выполнения

---

## Примечания

1. **Обработка ошибок**: Все исключения должны быть перехвачены и выведены пользователю
2. **Валидация данных**: Проверки выполняются на каждом этапе
3. **Циклы**: 
   - В New Route: цикл ввода остановок (до ввода "конец")
   - В Calculating Time: цикл расчета времени (от 1 до размера списка - 1)
4. **Индексация**: В Calculating Time первая остановка имеет индекс 0, расчет начинается со второй остановки (индекс 1)


