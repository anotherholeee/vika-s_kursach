# Расположение функций New Route и Calculating Time в коде

## 1. New Route (Создание маршрута) - Структурный элемент

Функция создания маршрута реализована в нескольких файлах и состоит из цепочки вызовов:

### 1.1. Точка входа (консольный интерфейс)

**Файл:** `ui.cpp`  
**Функция:** `adminAddRoute(TransportSystem& system)`  
**Строки:** 87-120

```cpp
void adminAddRoute(TransportSystem& system) {
    try {
        int number;
        std::string vehicleType;
        std::vector<std::string> stops;
        std::string stop;

        std::cout << "Введите номер маршрута: ";
        // ... ввод данных ...
        
        auto route = std::make_shared<Route>(number, vehicleType, stops);
        system.addRoute(route);  // ← Вызов метода добавления маршрута
        std::cout << "Маршрут успешно добавлен!\n";
    } catch (const std::exception& e) {
        std::cout << "Ошибка: " << e.what() << '\n';
    }
}
```

**Что делает:**
- Ввод номера маршрута
- Ввод типа транспорта
- Ввод списка остановок
- Создание объекта маршрута
- Вызов `system.addRoute(route)`

### 1.2. Проверка уникальности и создание команды

**Файл:** `transport_system.cpp`  
**Метод:** `TransportSystem::addRoute(std::shared_ptr<Route> route)`  
**Строки:** 144-151

```cpp
void TransportSystem::addRoute(std::shared_ptr<Route> route) {
    // Проверка уникальности номера маршрута
    for (const auto& existingRoute : routes) {
        if (existingRoute->getNumber() == route->getNumber()) {
            throw ContainerException("Маршрут с номером " + std::to_string(route->getNumber()) + " уже существует");
        }
    }
    // Создание команды для добавления (с поддержкой отмены)
    commandHistory.executeCommand(std::make_unique<AddRouteCommand>(this, route));
}
```

**Что делает:**
- ✅ Проверяет уникальность номера маршрута (соответствует алгоритму: "Проверка уникальности номера маршрута")
- ✅ Создает команду `AddRouteCommand` для поддержки отмены действий
- ✅ Выполняет команду через историю команд

### 1.3. Выполнение команды добавления

**Файл:** `commands.cpp`  
**Класс:** `AddRouteCommand`  
**Метод:** `AddRouteCommand::execute()`  
**Строки:** 7-9

```cpp
void AddRouteCommand::execute() {
    system->addRouteDirect(route);  // ← Прямое добавление в систему
}
```

**Что делает:**
- Вызывает прямой метод добавления маршрута (минуя проверки, так как они уже выполнены)

### 1.4. Прямое добавление маршрута в систему

**Файл:** `transport_system.cpp`  
**Метод:** `TransportSystem::addRouteDirect(std::shared_ptr<Route> route)`  
**Строки:** 376-378

```cpp
void TransportSystem::addRouteDirect(std::shared_ptr<Route> route) {
    routes.push_back(std::move(route));  // ← Добавление маршрута в список
}
```

**Что делает:**
- ✅ Добавляет маршрут в общий список `routes` (соответствует алгоритму: "Добавление маршрута в общий список")

### 1.5. Конструктор маршрута (проверка остановок)

**Файл:** `route.cpp`  
**Конструктор:** `Route::Route(int num, const std::string& vType, const std::vector<std::string>& stops, const std::set<int>& days)`  
**Строки:** 4-12

```cpp
Route::Route(int num, const std::string& vType, const std::vector<std::string>& stops, 
          const std::set<int>& days)
    : number(num), vehicleType(vType), allStops(stops), weekDays(days) {
    if (stops.empty()) {
        throw ContainerException("Маршрут не может быть пустым");
    }
    startStop = stops.front();  // ← Установка начальной остановки
    endStop = stops.back();     // ← Установка конечной остановки
}
```

**Что делает:**
- ✅ Проверяет, что маршрут не пустой
- ✅ Устанавливает начальную и конечную остановки из списка
- ⚠️ **Примечание:** В текущей реализации нет явной проверки, что начальная и конечная остановки разные. Это можно добавить здесь или в `addRoute()`.

### 1.6. Графический интерфейс (Qt)

**Файл:** `qt_ui.cpp`  
**Класс:** `AddRouteDialog`  
**Метод:** `AddRouteDialog::onAddClicked()`  
**Строки:** 1552-1589

```cpp
void AddRouteDialog::onAddClicked() {
    if (stopsListWidget->count() < 2) {
        QMessageBox::warning(this, "Ошибка", "Маршрут должен содержать минимум 2 остановки.");
        return;
    }
    
    try {
        int number = routeNumberSpinBox->value();
        std::string vehicleType = vehicleTypeComboBox->currentText().toStdString();
        
        std::vector<std::string> stops;
        for (int i = 0; i < stopsListWidget->count(); ++i) {
            stops.push_back(stopsListWidget->item(i)->text().toStdString());
        }
        
        // ... работа с днями недели ...
        
        auto route = std::make_shared<Route>(number, vehicleType, stops, weekDays);
        transportSystem->addRoute(route);  // ← Вызов того же метода
        
        QMessageBox::information(this, "Успех", "Маршрут добавлен.");
        accept();
    } catch (const std::exception& e) {
        QMessageBox::critical(this, "Ошибка", QString("Ошибка: %1").arg(e.what()));
    }
}
```

---

## 2. Calculating Time (Расчет времени прибытия) - Сервисный элемент

Функция расчета времени прибытия реализована через паттерн Strategy:

### 2.1. Точка входа (консольный интерфейс)

**Файл:** `ui.cpp`  
**Функция:** `calculateArrivalTime(TransportSystem& system)`  
**Строки:** 688-743

```cpp
void calculateArrivalTime(TransportSystem& system) {
    try {
        // ... вывод списка рейсов ...
        
        int tripId;
        double speed;

        std::cout << "Введите ID рейса: ";
        // ... ввод tripId ...
        std::cout << "Введите среднюю скорость (км/ч): ";
        // ... ввод speed ...
        
        system.calculateArrivalTimes(tripId, speed);  // ← Вызов метода расчета
        
        // ... вывод результатов ...
    } catch (const std::exception& e) {
        std::cout << "Ошибка: " << e.what() << '\n';
    }
}
```

**Что делает:**
- Ввод ID рейса
- Ввод средней скорости
- Вызов `system.calculateArrivalTimes(tripId, speed)`

### 2.2. Делегирование алгоритму (TransportSystem)

**Файл:** `transport_system.cpp`  
**Метод:** `TransportSystem::calculateArrivalTimes(int tripId, double averageSpeed)`  
**Строки:** 131-134

```cpp
void TransportSystem::calculateArrivalTimes(int tripId, double averageSpeed) {
    // Используем алгоритм расчета времени прибытия
    arrivalTimeAlgorithm->calculateArrivalTimes(tripId, averageSpeed);
}
```

**Что делает:**
- Делегирует выполнение алгоритму расчета времени прибытия (паттерн Strategy)

### 2.3. Основной алгоритм расчета времени

**Файл:** `algorithm.cpp`  
**Класс:** `ArrivalTimeCalculationAlgorithm`  
**Метод:** `ArrivalTimeCalculationAlgorithm::calculateArrivalTimes(int tripId, double averageSpeed)`  
**Строки:** 113-145

```cpp
void ArrivalTimeCalculationAlgorithm::calculateArrivalTimes(int tripId, double averageSpeed) {
    // Проверка скорости
    if (averageSpeed <= 0) {
        throw InputException("Средняя скорость должна быть положительной");
    }

    // Поиск рейса
    const auto& trips = system->getTrips();
    auto tripIt = std::find_if(trips.begin(), trips.end(),
                               [tripId](const auto& t) { return t->getTripId() == tripId; });

    if (tripIt == trips.end()) {
        throw ContainerException("Рейс с ID " + std::to_string(tripId) + " не найден");
    }

    auto trip = *tripIt;
    const auto& stopsList = trip->getRoute()->getAllStops();

    if (stopsList.empty()) {
        throw ContainerException("Маршрут не содержит остановок");
    }

    // ✅ Получить время отправления с начальной остановки
    Time currentTime = trip->getStartTime();
    trip->setArrivalTime(stopsList[0], currentTime);  // ← Время прибытия = время отправления

    const double distanceBetweenStops = 1.5; // км
    const int stopTime = 1; // минута

    // ✅ Цикл расчета времени для всех остановок
    for (size_t i = 1; i < stopsList.size(); ++i) {
        // ✅ Рассчитать время в пути
        double travelTimeMinutes = (distanceBetweenStops / averageSpeed) * 60;
        // ✅ Время прибытия на i+1 = текущее время + время в пути
        Time arrivalTime = currentTime + static_cast<int>(travelTimeMinutes + 0.5);
        // ✅ Записать время прибытия для остановки i+1
        trip->setArrivalTime(stopsList[i], arrivalTime);
        // ✅ Время отправления с i+1 = время прибытия + время стоянки
        currentTime = arrivalTime + stopTime;
    }
}
```

**Что делает (соответствие алгоритму):**
- ✅ Проверяет, что рейс найден (блок условие: "Рейс найден?")
- ✅ Получает маршрут рейса
- ✅ Получает список остановок маршрута
- ✅ Получает время отправления с начальной остановки
- ✅ Устанавливает текущее время = время отправления
- ✅ **Цикл:** Пока текущая остановка < последней:
  - ✅ Рассчитывает расстояние между остановками (константа 1.5 км)
  - ✅ Рассчитывает время в пути: `(расстояние / скорость) * 60`
  - ✅ Время прибытия на i+1 = текущее время + время в пути
  - ✅ Записывает время прибытия для остановки i+1
  - ✅ Время отправления с i+1 = время прибытия + время стоянки
  - ✅ Текущее время = время отправления с i+1
- ✅ Сохраняет рассчитанное расписание для рейса (через `setArrivalTime`)

### 2.4. Сохранение времени в рейсе

**Файл:** `trip.cpp`  
**Метод:** `Trip::setArrivalTime(const std::string& stop, const Time& time)`  
**Строки:** (нужно проверить)

Метод сохраняет время прибытия в расписании рейса (`schedule` map).

### 2.5. Графический интерфейс (Qt)

**Файл:** `qt_ui.cpp`  
**Класс:** `ArrivalTimeDialog`  
**Метод:** `ArrivalTimeDialog::onCalculateClicked()`  
**Строки:** 2054-2059

```cpp
void ArrivalTimeDialog::onCalculateClicked() {
    int tripId = tripComboBox->currentData().toInt();
    double speed = speedSpinBox->value();
    
    transportSystem->calculateArrivalTimes(tripId, speed);  // ← Вызов того же метода
    // ... вывод результатов ...
}
```

---

## Схема вызовов функций

### New Route (Создание маршрута):
```
adminAddRoute() [ui.cpp:87]
    ↓
TransportSystem::addRoute() [transport_system.cpp:144]
    ├─ Проверка уникальности номера
    └─ commandHistory.executeCommand()
        ↓
    AddRouteCommand::execute() [commands.cpp:7]
        ↓
    TransportSystem::addRouteDirect() [transport_system.cpp:376]
        ↓
    routes.push_back() ← Добавление в список
```

### Calculating Time (Расчет времени):
```
calculateArrivalTime() [ui.cpp:688]
    ↓
TransportSystem::calculateArrivalTimes() [transport_system.cpp:131]
    ↓
ArrivalTimeCalculationAlgorithm::calculateArrivalTimes() [algorithm.cpp:113]
    ├─ Поиск рейса
    ├─ Получение маршрута и остановок
    ├─ Установка времени отправления
    └─ Цикл расчета для каждой остановки:
        ├─ Расчет времени в пути
        ├─ Расчет времени прибытия
        ├─ Сохранение времени прибытия
        └─ Расчет времени отправления
```

---

## Соответствие алгоритмам

### New Route:
✅ **Ввод номера маршрута** - `ui.cpp:94-99`  
✅ **Ввод типа транспорта** - `ui.cpp:102-103`  
✅ **Выбор остановок** - `ui.cpp:105-111`  
⚠️ **Проверка: начальная и конечная остановка разные?** - Не реализовано явно (можно добавить в `Route` конструктор или `addRoute`)  
✅ **Проверка уникальности номера маршрута** - `transport_system.cpp:145-149`  
✅ **Создание объекта маршрута** - `ui.cpp:113`  
✅ **Добавление маршрута в общий список** - `transport_system.cpp:377`  
✅ **Вывод сообщения об успешном создании** - `ui.cpp:115`

### Calculating Time:
✅ **Входные данные: номер маршрута, скорость** - `ui.cpp:706-721`  
✅ **Проверка: Рейс найден?** - `algorithm.cpp:119-124`  
✅ **Получить маршрут рейса** - `algorithm.cpp:127`  
✅ **Получить список остановок маршрута** - `algorithm.cpp:127`  
✅ **Получить время отправления** - `algorithm.cpp:133`  
✅ **Текущее время = время отправления** - `algorithm.cpp:133-134`  
✅ **Цикл: Пока текущая остановка < последней** - `algorithm.cpp:139`  
✅ **Рассчитать расстояние между остановками** - `algorithm.cpp:136`  
✅ **Рассчитать время в пути** - `algorithm.cpp:140`  
✅ **Время прибытия на i+1 = текущее время + время в пути** - `algorithm.cpp:141`  
✅ **Записать время прибытия для остановки i+1** - `algorithm.cpp:142`  
✅ **Время отправления с i+1 = время прибытия + время стоянки** - `algorithm.cpp:143`  
✅ **Текущее время = время отправления с i+1** - `algorithm.cpp:143`  
✅ **Сохранить рассчитанное расписание** - через `setArrivalTime()` в цикле


