# Описание алгоритма добавления маршрута (New Route)

## Упрощенный алгоритм для блок-схемы

```
АЛГОРИТМ: Создание нового маршрута

НАЧАЛО

1. Объявить переменные:
   - routeNumber (int)
   - transportType (string)
   - stops (vector<string>)
   - startStop (string)
   - endStop (string)
   - newRoute (shared_ptr<Route>)

2. Ввести routeNumber
   ЕСЛИ ввод некорректен ТО
      Вывести ошибку ввода
      КОНЕЦ
   КОНЕЦ ЕСЛИ

3. Ввести transportType

4. Ввести список остановок (цикл до ввода "конец")
   ПОКА stop != "конец"
      Ввести stop
      stops.push_back(stop)
   КОНЕЦ ПОКА

5. ЕСЛИ stops.empty() ТО
      Вывести ошибку: "Маршрут не может быть пустым"
      КОНЕЦ
   КОНЕЦ ЕСЛИ

6. startStop = stops.front()
   endStop = stops.back()

7. ЕСЛИ startStop == endStop ТО
      Вывести ошибку: "Начальная и конечная остановки не могут совпадать"
      КОНЕЦ
   КОНЕЦ ЕСЛИ

8. newRoute = make_shared<Route>(routeNumber, transportType, stops)

9. Вызвать system.addRoute(newRoute)
   
   9.1. ДЛЯ каждого existingRoute в routes:
         ЕСЛИ existingRoute->getNumber() == routeNumber ТО
            Вывести ошибку: "Маршрут с номером [номер] уже существует"
            КОНЕЦ
         КОНЕЦ ЕСЛИ
       КОНЕЦ ДЛЯ
   
   9.2. cmd = AddRouteCommand(system, newRoute)
   
   9.3. commandHistory.executeCommand(cmd)
        → AddRouteCommand::execute()
        → system->addRouteDirect(newRoute)
        → routes.push_back(newRoute)

10. Вывести: "Маршрут успешно добавлен!"

КОНЕЦ

## Исключения (Exceptions) в алгоритме

В процессе выполнения алгоритма могут быть выброшены следующие исключения:

### 1. InputException
**Где возникает:** Шаг 2 (Ввод routeNumber)
- **Сообщение:** "Неверный формат ввода для номера маршрута"
- **Условие:** Некорректный ввод номера маршрута (не число)
- **Код:** `throw InputException("Неверный формат ввода для номера маршрута");`

### 2. ContainerException
**Где возникает:** Шаг 5 (Проверка пустоты списка остановок)
- **Сообщение:** "Маршрут не может быть пустым"
- **Условие:** `stops.empty() == true`
- **Код:** `throw ContainerException("Маршрут не может быть пустым");`
- **Место:** В конструкторе `Route::Route()`

### 3. ContainerException
**Где возникает:** Шаг 7 (Проверка совпадения остановок)
- **Сообщение:** "Начальная и конечная остановки не могут совпадать"
- **Условие:** `startStop == endStop`
- **Код:** `throw ContainerException("Начальная и конечная остановки не могут совпадать");`
- **Примечание:** Эта проверка описана в алгоритме, но в текущей реализации кода отсутствует. Рекомендуется добавить.

### 4. ContainerException
**Где возникает:** Шаг 9.1 (Проверка уникальности номера маршрута)
- **Сообщение:** "Маршрут с номером [номер] уже существует"
- **Условие:** `existingRoute->getNumber() == routeNumber`
- **Код:** `throw ContainerException("Маршрут с номером " + std::to_string(routeNumber) + " уже существует");`
- **Место:** В методе `TransportSystem::addRoute()`

## Иерархия исключений

```
std::exception
    └── TransportException (базовый класс)
        ├── InputException (ошибки ввода)
        ├── ContainerException (ошибки работы с контейнерами)
        └── FileException (ошибки работы с файлами)
```

## Обработка исключений

Все исключения перехватываются в блоке `try-catch` функции `adminAddRoute()`:

```cpp
try {
    // ... выполнение алгоритма ...
} catch (const std::exception& e) {
    std::cout << "Ошибка: " << e.what() << '\n';
}
```

Это означает, что любое исключение (InputException, ContainerException и их базовый класс TransportException) будет перехвачено и выведено сообщение об ошибке.
```

## Блок-схема алгоритма

```
Начало
    ↓
Ввод номера маршрута (routeNumber)
    ↓
Ввод типа транспорта (transportType)
    ↓
Ввод списка остановок (цикл: ввод остановок до "конец")
    ↓
Определение начальной остановки: startStop = stops.front()
    ↓
Определение конечной остановки: endStop = stops.back()
    ↓
┌─────────────────────────────────────────────┐
│ Проверка: startStop == endStop?            │
└─────────────────────────────────────────────┘
    ↓
    ├─→ ДА (остановки совпадают)
    │       ↓
    │   Выброс исключения ContainerException
    │       ↓
    │   Вывод ошибки: "Начальная и конечная остановки не могут совпадать"
    │       ↓
    │   Конец
    │
    └─→ НЕТ (остановки разные)
            ↓
        Создание объекта маршрута: newRoute = Route(routeNumber, transportType, stops)
            ↓
        Вызов system.addRoute(newRoute)
            ↓
        ┌─────────────────────────────────────────────┐
        │ Проверка уникальности номера маршрута      │
        │ Для каждого existingRoute в routes:       │
        │   existingRoute->getNumber() == routeNumber?│
        └─────────────────────────────────────────────┘
            ↓
            ├─→ ДА (номер уже существует)
            │       ↓
            │   Выброс исключения ContainerException
            │       ↓
            │   Вывод ошибки: "Маршрут с номером [номер] уже существует"
            │       ↓
            │   Конец
            │
            └─→ НЕТ (номер уникален)
                    ↓
                Создание команды: cmd = AddRouteCommand(system, newRoute)
                    ↓
                commandHistory.executeCommand(cmd)
                    ↓
                AddRouteCommand::execute()
                    ↓
                system->addRouteDirect(newRoute)
                    ↓
                routes.push_back(newRoute)
                    ↓
                Вывод сообщения: "Маршрут успешно добавлен!"
                    ↓
                Конец
```

## Подробный алгоритм создания маршрута

### Начало

### Шаг 1: Объявить переменные

- `int routeNumber` - номер маршрута
- `std::string transportType` - тип транспорта
- `std::vector<std::string> stops` - вектор названий остановок
- `std::string stop` - временная переменная для ввода остановки
- `std::string startStop` - название начальной остановки
- `std::string endStop` - название конечной остановки
- `std::shared_ptr<Route> newRoute` - умный указатель на новый маршрут

### Шаг 2: Ввести данные

**2.1. Ввести номер маршрута:**
- Вывести приглашение: "Введите номер маршрута: "
- Считать `routeNumber` из стандартного ввода
- Если ввод некорректен:
  - Очистить буфер ввода
  - Сгенерировать исключение `InputException` с сообщением "Неверный формат ввода для номера маршрута"
  - Перейти к обработке исключений (Шаг 7)
- Очистить буфер ввода после чтения числа

**2.2. Ввести тип транспорта:**
- Вывести приглашение: "Введите тип транспорта (Автобус/Трамвай/Троллейбус): "
- Считать `transportType` из стандартного ввода (полная строка)

**2.3. Ввести список остановок:**
- Вывести приглашение: "Введите остановки маршрута (введите 'конец' для завершения):"
- **Начало цикла (пока true):**
  - Вывести приглашение: "Остановка: "
  - Считать `stop` из стандартного ввода
  - **Проверка условия:** `stop == "конец"`
    - Если ДА: выйти из цикла
    - Если НЕТ: добавить `stop` в вектор `stops`
- **Конец цикла**

**2.4. Определить начальную и конечную остановки:**
- Проверить: `stops.empty()`
  - Если ДА: сгенерировать исключение `ContainerException` с сообщением "Маршрут не может быть пустым"
- `startStop = stops.front()` (первая остановка в списке)
- `endStop = stops.back()` (последняя остановка в списке)

### Шаг 3: Проверить, что начальная и конечная остановки разные

**Проверка условия:** `startStop == endStop`

- **Если ДА (остановки совпадают):**
  - Сгенерировать исключение `ContainerException` с сообщением "Начальная и конечная остановки не могут совпадать"
  - Перейти к обработке исключений (Шаг 7)

- **Если НЕТ (остановки разные):**
  - Перейти к Шагу 4

### Шаг 4: Создать объект маршрута

- `newRoute = std::make_shared<Route>(routeNumber, transportType, stops)`
- В конструкторе Route автоматически устанавливаются:
  - `startStop = stops.front()`
  - `endStop = stops.back()`

### Шаг 5: Вызвать метод добавления маршрута в систему

- Вызвать: `system.addRoute(newRoute)`

**В методе `TransportSystem::addRoute()`:**

**5.1. Проверить уникальность номера маршрута:**
- **Начало цикла:** Для каждого маршрута `existingRoute` в списке `routes`:
  - **Проверка условия:** `existingRoute->getNumber() == routeNumber`
    - **Если ДА (номер уже существует):**
      - Сгенерировать исключение `ContainerException` с сообщением "Маршрут с номером [routeNumber] уже существует"
      - Перейти к обработке исключений (Шаг 7)
    - **Если НЕТ:** продолжить проверку следующего маршрута
- **Конец цикла**

**5.2. Создать команду для добавления:**
- `cmd = std::make_unique<AddRouteCommand>(this, newRoute)`

**5.3. Выполнить команду через историю:**
- Вызвать: `commandHistory.executeCommand(std::move(cmd))`

**В методе `CommandHistory::executeCommand()`:**
- Удалить команды после текущего индекса (если были отмены)
- Вызвать `cmd->execute()` для выполнения команды
- Добавить команду в историю: `history.push_back(std::move(cmd))`
- Обновить текущий индекс: `currentIndex = history.size()`
- Если размер истории превышает `MAX_HISTORY_SIZE`, удалить самую старую команду

**В методе `AddRouteCommand::execute()`:**
- Вызвать: `system->addRouteDirect(newRoute)`

**В методе `TransportSystem::addRouteDirect()`:**
- Добавить маршрут в вектор: `routes.push_back(std::move(newRoute))`

### Шаг 6: Вывести сообщение об успешном создании

- Вывести: "Маршрут успешно добавлен!"
- Перейти к Шагу 8 (Конец)

### Шаг 7: Обработка исключений

- Перехватить исключение типа `std::exception`
- Вывести: "Ошибка: [сообщение исключения]"
- Перейти к Шагу 8 (Конец)

### Шаг 8: Конец

## Особенности реализации

1. **Паттерн Command:** Использование паттерна Command позволяет:
   - Отменять операции (undo)
   - Сохранять историю действий
   - Разделять валидацию и выполнение

2. **Проверка уникальности:** Выполняется в `addRoute()` перед созданием команды

3. **Прямое добавление:** Метод `addRouteDirect()` используется для фактического добавления в контейнер, минуя валидацию

4. **Отсутствующая проверка:** В текущей реализации нет явной проверки, что начальная и конечная остановки разные. Рекомендуется добавить проверку в конструктор `Route` или в `addRoute()`:
   ```cpp
   if (route->getStartStop() == route->getEndStop()) {
       throw ContainerException("Начальная и конечная остановки не могут совпадать");
   }
   ```

## Структура вызовов

```
adminAddRoute()
    ↓
Route::Route() [конструктор]
    ↓
TransportSystem::addRoute()
    ↓
CommandHistory::executeCommand()
    ↓
AddRouteCommand::execute()
    ↓
TransportSystem::addRouteDirect()
    ↓
routes.push_back() [фактическое добавление]
```

