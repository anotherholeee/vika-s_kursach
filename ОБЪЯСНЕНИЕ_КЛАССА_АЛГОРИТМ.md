# Что такое класс Algorithm и зачем он нужен?

## Простое объяснение

**Класс Algorithm** — это способ "упаковать" сложную логику вычислений в отдельный объект, который можно легко использовать, заменять и расширять.

## Аналогия из жизни

Представьте, что у вас есть задача "найти самый быстрый путь от точки A до точки B". 

**Без классов алгоритмов:**
- Вся логика поиска "размазана" по коду
- Сложно понять, где заканчивается один алгоритм и начинается другой
- Трудно заменить один способ поиска на другой

**С классами алгоритмов:**
- Каждый алгоритм — это отдельный класс
- Можно легко переключаться между разными алгоритмами
- Код становится понятнее и организованнее

## Зачем нужен класс Algorithm в вашем коде?

### 1. **Разделение ответственности (Separation of Concerns)**
Вместо того, чтобы вся логика поиска была в `JourneyPlanner`, она вынесена в отдельные классы:
- `BFSAlgorithm` — ищет все возможные маршруты
- `FastestPathAlgorithm` — находит самый быстрый
- `MinimalTransfersAlgorithm` — находит с минимальными пересадками

### 2. **Возможность замены алгоритмов (Strategy Pattern)**
Можно легко заменить один алгоритм на другой без изменения остального кода:

```cpp
// Используем BFS
BFSAlgorithm bfs(system, 2);
auto routes = bfs.findPath("Остановка A", "Остановка B", time);

// Или используем другой алгоритм
FastestPathAlgorithm fastest(system);
auto routes = fastest.findPath("Остановка A", "Остановка B", time);
```

### 3. **Расширяемость**
Легко добавить новый алгоритм, просто создав новый класс:

```cpp
class DijkstraAlgorithm : public PathFindingAlgorithm {
    // Новый алгоритм поиска пути
};
```

### 4. **Тестируемость**
Каждый алгоритм можно тестировать отдельно от остального кода.

### 5. **Соответствие принципам ООП**
- **Инкапсуляция:** Логика алгоритма скрыта внутри класса
- **Наследование:** Все алгоритмы наследуются от базового класса
- **Полиморфизм:** Можно работать с разными алгоритмами через один интерфейс
- **Абстракция:** Базовый класс определяет общий интерфейс

## Примеры из вашего кода

### До (без классов алгоритмов):
```cpp
// Вся логика поиска была прямо в JourneyPlanner
std::vector<Journey> JourneyPlanner::findJourneysWithTransfers(...) {
    // 100+ строк кода поиска прямо здесь
    std::queue<SearchNode> q;
    while (!q.empty()) {
        // сложная логика...
    }
}
```

### После (с классами алгоритмов):
```cpp
// Логика вынесена в отдельный класс
class BFSAlgorithm : public PathFindingAlgorithm {
    std::vector<Journey> findPath(...) {
        // Алгоритм поиска в ширину
    }
};

// Использование:
BFSAlgorithm bfs(system, 2);
auto journeys = bfs.findPath(start, end, time);
```

## Преимущества для вашего проекта

1. **Читаемость:** Код становится понятнее
2. **Поддерживаемость:** Легче исправлять и улучшать алгоритмы
3. **Переиспользование:** Один алгоритм можно использовать в разных местах
4. **Гибкость:** Можно легко добавить новые алгоритмы (например, A*, Dijkstra)
5. **Соответствие требованиям:** Демонстрирует понимание ООП и паттернов проектирования

## Где используются алгоритмы в вашем коде?

1. **JourneyPlanner** использует:
   - `BFSAlgorithm` — для поиска всех маршрутов
   - `FastestPathAlgorithm` — для поиска самого быстрого
   - `MinimalTransfersAlgorithm` — для поиска с минимальными пересадками

2. **TransportSystem** использует:
   - `ArrivalTimeCalculationAlgorithm` — для расчета времени прибытия
   - `RouteSearchAlgorithm` — для поиска маршрутов между остановками

## Итог

Класс Algorithm — это способ организовать сложные вычисления в виде объектов, которые можно легко использовать, заменять и расширять. Это делает код более профессиональным и соответствует принципам ООП.

