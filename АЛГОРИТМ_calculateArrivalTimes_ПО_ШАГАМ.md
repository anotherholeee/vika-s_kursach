# Алгоритм по шагам для функции calculateArrivalTimes

## Шаг 1. Начало.

**Входные данные:**
- `int tripId` – идентификатор рейса, для которого требуется рассчитать время прибытия;
- `double averageSpeed` – средняя скорость движения транспортного средства в километрах в час.

**Выходные данные:**
- Функция не возвращает значение (тип `void`), но обновляет расписание рейса, устанавливая время прибытия на каждую остановку маршрута.

## Шаг 2. Проверить корректность средней скорости.

Проверить условие `averageSpeed <= 0`. Если условие истинно, сгенерировать исключение `InputException` с сообщением "Средняя скорость должна быть положительной" и завершить выполнение функции. Если условие ложно, продолжить выполнение.

## Шаг 3. Получить список всех рейсов системы.

Вызвать метод `system->getTrips()` и сохранить результат в константную ссылку `const auto& trips`.

## Шаг 4. Найти рейс с указанным идентификатором.

Использовать алгоритм `std::find_if` для поиска рейса в списке `trips`, у которого идентификатор совпадает с параметром `tripId`. Сохранить результат поиска в итератор `auto tripIt`.

## Шаг 5. Проверить наличие рейса в системе.

Проверить условие `tripIt == trips.end()`. Если условие истинно (рейс не найден), сгенерировать исключение `ContainerException` с сообщением "Рейс с ID [tripId] не найден" и завершить выполнение функции. Если условие ложно, продолжить выполнение.

## Шаг 6. Получить объект рейса.

Получить объект рейса из итератора: `auto trip = *tripIt`.

## Шаг 7. Получить список остановок маршрута рейса.

Вызвать метод `trip->getRoute()->getAllStops()` и сохранить результат в константную ссылку `const auto& stopsList`.

## Шаг 8. Проверить наличие остановок в маршруте.

Проверить условие `stopsList.empty()`. Если условие истинно (маршрут не содержит остановок), сгенерировать исключение `ContainerException` с сообщением "Маршрут не содержит остановок" и завершить выполнение функции. Если условие ложно, продолжить выполнение.

## Шаг 9. Получить время отправления рейса.

Вызвать метод `trip->getStartTime()` и сохранить результат в переменную `Time currentTime`.

## Шаг 10. Установить время прибытия на начальную остановку.

Установить время прибытия на первую остановку маршрута (с индексом 0), вызвав метод `trip->setArrivalTime(stopsList[0], currentTime)`. Время прибытия на начальную остановку равно времени отправления рейса.

## Шаг 11. Инициализировать константы расчета.

Установить константы для расчета:
- `const double distanceBetweenStops = 1.5` – расстояние между остановками в километрах;
- `const int stopTime = 1` – время стоянки на остановке в минутах.

## Шаг 12. Начать цикл по остальным остановкам маршрута.

Организовать цикл `for (size_t i = 1; i < stopsList.size(); ++i)`, где `i` – индекс текущей остановки (начинается с 1, так как первая остановка уже обработана).

## Шаг 13. Рассчитать время движения до текущей остановки.

Вычислить время движения в минутах по формуле:
- `double travelTimeMinutes = (distanceBetweenStops / averageSpeed) * 60`

Формула: время движения = (расстояние / скорость) × 60 (для перевода часов в минуты).

## Шаг 14. Рассчитать время прибытия на текущую остановку.

Вычислить время прибытия, добавив время движения к текущему времени и округлив до ближайшего целого числа минут:
- `Time arrivalTime = currentTime + static_cast<int>(travelTimeMinutes + 0.5)`

Использование `static_cast<int>(travelTimeMinutes + 0.5)` обеспечивает округление до ближайшего целого числа минут.

## Шаг 15. Записать время прибытия для текущей остановки.

Вызвать метод `trip->setArrivalTime(stopsList[i], arrivalTime)` для сохранения времени прибытия на остановку с индексом `i`.

## Шаг 16. Рассчитать время отправления со следующей остановки.

Вычислить время отправления, добавив время стоянки к времени прибытия:
- `currentTime = arrivalTime + stopTime`

Формула: время отправления = время прибытия + время стоянки.

**Примечание:** В текущей реализации время отправления не сохраняется отдельно, а используется как `currentTime` для расчета следующей остановки.

## Шаг 17. Завершить итерацию цикла по остановкам.

Продолжить итерацию до конца списка остановок `stopsList`. Если обработаны не все остановки (`i < stopsList.size() - 1`), вернуться к Шагу 12 для обработки следующей остановки. Если обработана последняя остановка (`i == stopsList.size() - 1`), перейти к Шагу 18.

## Шаг 18. Завершить расчет времени прибытия.

Все времена прибытия рассчитаны и сохранены в расписании рейса через метод `setArrivalTime()`.

**Примечание:** В текущей реализации метод `calculateArrivalTimes` не вызывает явный метод сохранения расписания, так как времена сохраняются непосредственно в объекте `Trip` через метод `setArrivalTime()`.

## Шаг 19. Конец алгоритма.

Завершить выполнение функции. Расписание рейса обновлено с рассчитанными временами прибытия на все остановки маршрута.


