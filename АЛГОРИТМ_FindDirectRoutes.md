# Алгоритм функции FindDirectRoutes (Поиск прямых маршрутов)

## Описание функции

Функция `FindDirectRoutes` находит все прямые маршруты между двумя остановками. Прямым маршрутом считается маршрут, который проходит через обе остановки, причем начальная остановка находится раньше конечной в последовательности остановок маршрута.

## Алгоритм для блок-схемы

### Входные данные:
- `stopA` (строка) - начальная остановка
- `stopB` (строка) - конечная остановка

### Выходные данные:
- `foundRoutes` (вектор маршрутов) - список найденных прямых маршрутов

### Пошаговый алгоритм:

1. **НАЧАЛО**
   - Создать пустой список `foundRoutes` для хранения найденных маршрутов

2. **Получить список всех маршрутов системы**
   - `routes = system->getRoutes()`

3. **ЦИКЛ: Для каждого маршрута `route` в списке `routes`**
   
   3.1. **Проверка 1: Маршрут содержит остановку A?**
      - Вызвать `route->containsStop(stopA)`
      - Если НЕТ → перейти к следующему маршруту (шаг 3)
      - Если ДА → продолжить проверку 2
   
   3.2. **Проверка 2: Маршрут содержит остановку B?**
      - Вызвать `route->containsStop(stopB)`
      - Если НЕТ → перейти к следующему маршруту (шаг 3)
      - Если ДА → продолжить проверку 3
   
   3.3. **Проверка 3: Остановка A находится перед остановкой B?**
      - Вызвать `route->isStopBefore(stopA, stopB)`
      - Если НЕТ → перейти к следующему маршруту (шаг 3)
      - Если ДА → маршрут подходит
   
   3.4. **Добавить маршрут в результат**
      - `foundRoutes.push_back(route)`
   
   3.5. **Перейти к следующему маршруту**

4. **КОНЕЦ ЦИКЛА** (когда все маршруты проверены)

5. **Вернуть результат**
   - Вернуть `foundRoutes`

6. **КОНЕЦ**

---

## Блок-схема (текстовое описание)

```
┌─────────────┐
│   НАЧАЛО    │
└──────┬──────┘
       │
       ▼
┌─────────────────────────┐
│ foundRoutes = []        │
│ (пустой список)         │
└──────┬──────────────────┘
       │
       ▼
┌─────────────────────────┐
│ routes =                │
│ system->getRoutes()     │
└──────┬──────────────────┘
       │
       ▼
┌─────────────────────────┐
│ Есть еще маршруты?      │
└──────┬──────────────────┘
       │
       ├─── НЕТ ──────────┐
       │                  │
       ▼ ДА                │
┌─────────────────────────┐│
│ route = текущий         ││
│ маршрут                 ││
└──────┬──────────────────┘│
       │                   │
       ▼                   │
┌─────────────────────────┐│
│ route содержит stopA?   ││
└──────┬──────────────────┘│
       │                   │
       ├─── НЕТ ───────────┤
       │                   │
       ▼ ДА                │
┌─────────────────────────┐│
│ route содержит stopB?    ││
└──────┬──────────────────┘│
       │                   │
       ├─── НЕТ ───────────┤
       │                   │
       ▼ ДА                │
┌─────────────────────────┐│
│ stopA перед stopB?       ││
└──────┬──────────────────┘│
       │                   │
       ├─── НЕТ ───────────┤
       │                   │
       ▼ ДА                │
┌─────────────────────────┐│
│ foundRoutes.add(route)  ││
└──────┬──────────────────┘│
       │                   │
       └───────────────────┘
       │
       ▼
┌─────────────────────────┐
│ Вернуть foundRoutes     │
└──────┬──────────────────┘
       │
       ▼
┌─────────────┐
│    КОНЕЦ    │
└─────────────┘
```

---

## Код функции

### 1. Основной алгоритм (RouteSearchAlgorithm::findRoutes)

**Файл:** `algorithm.cpp`  
**Строки:** 147-160

```cpp
std::vector<std::shared_ptr<Route>> RouteSearchAlgorithm::findRoutes(
    const std::string& stopA, 
    const std::string& stopB) {
    
    // Шаг 1: Создать пустой список для результатов
    std::vector<std::shared_ptr<Route>> foundRoutes;
    
    // Шаг 2: Получить список всех маршрутов системы
    const auto& routes = system->getRoutes();
    
    // Шаг 3: Цикл по всем маршрутам
    for (const auto& route : routes) {
        // Шаг 3.1: Проверка 1 - маршрут содержит остановку A?
        // Шаг 3.2: Проверка 2 - маршрут содержит остановку B?
        // Шаг 3.3: Проверка 3 - остановка A находится перед остановкой B?
        if (route->containsStop(stopA) &&
            route->containsStop(stopB) &&
            route->isStopBefore(stopA, stopB)) {
            
            // Шаг 3.4: Добавить маршрут в результат
            foundRoutes.push_back(route);
        }
    }
    
    // Шаг 5: Вернуть результат
    return foundRoutes;
}
```

### 2. Вспомогательные методы класса Route

**Файл:** `route.cpp`

#### Метод containsStop (проверка наличия остановки в маршруте)
**Строки:** 14-16

```cpp
bool Route::containsStop(const std::string& stop) const {
    return std::find(allStops.begin(), allStops.end(), stop) != allStops.end();
}
```

#### Метод isStopBefore (проверка, что остановка A находится перед остановкой B)
**Строки:** 26-30

```cpp
bool Route::isStopBefore(const std::string& stopA, const std::string& stopB) const {
    int posA = getStopPosition(stopA);  // Получить позицию остановки A
    int posB = getStopPosition(stopB);   // Получить позицию остановки B
    return posA != -1 && posB != -1 && posA < posB;  // Проверка: обе найдены и A < B
}
```

#### Метод getStopPosition (получение позиции остановки в маршруте)
**Строки:** 18-24

```cpp
int Route::getStopPosition(const std::string& stop) const {
    auto it = std::find(allStops.begin(), allStops.end(), stop);
    if (it != allStops.end()) {
        return static_cast<int>(std::distance(allStops.begin(), it));
    }
    return -1;  // Остановка не найдена
}
```

### 3. Вызов из TransportSystem

**Файл:** `transport_system.cpp`  
**Строки:** 71-74

```cpp
std::vector<std::shared_ptr<Route>> TransportSystem::findRoutes(
    const std::string& stopA, 
    const std::string& stopB) {
    // Делегирование выполнения алгоритму поиска маршрутов
    return routeSearchAlgorithm->findRoutes(stopA, stopB);
}
```

### 4. Пример использования из UI

**Файл:** `ui.cpp`  
**Строки:** 365-405

```cpp
void searchRoutes(TransportSystem& system) {
    try {
        std::string stopAInput, stopBInput;

        // Вывод списка остановок для выбора
        displayAllStopsForSelection(system);

        // Ввод начальной остановки
        std::cout << "\nВведите начальную остановку (ID или название): ";
        std::getline(std::cin, stopAInput);
        
        // Ввод конечной остановки
        std::cout << "Введите конечную остановку (ID или название): ";
        std::getline(std::cin, stopBInput);

        // Преобразование ввода в названия остановок
        std::string stopA = getStopNameByInput(system, stopAInput);
        std::string stopB = getStopNameByInput(system, stopBInput);

        // ВЫЗОВ ФУНКЦИИ FindDirectRoutes
        auto routes = system.findRoutes(stopA, stopB);
        
        // Вывод результатов
        std::cout << "\nНайдено маршрутов: " << routes.size() << '\n';

        if (routes.empty()) {
            std::cout << "Прямых маршрутов не найдено. Попробуйте поиск с пересадками.\n";
        } else {
            // Вывод информации о каждом найденном маршруте
            for (const auto& route : routes) {
                std::cout << "\nМаршрут " << route->getNumber() << " ("
                          << route->getVehicleType() << ")\n";

                const auto& allStops = route->getAllStops();
                int startPos = route->getStopPosition(stopA);
                int endPos = route->getStopPosition(stopB);

                if (startPos != -1 && endPos != -1 && startPos < endPos) {
                    std::cout << "Путь: " << allStops[startPos];
                    for (int i = startPos + 1; i <= endPos; i++) {
                        std::cout << " → " << allStops[i];
                    }
                    std::cout << '\n';
                }
            }
        }
    } catch (const std::exception& e) {
        std::cout << "Ошибка: " << e.what() << "\n";
    }
}
```

---

## Описание проверок

### Проверка 1: `route->containsStop(stopA)`
- **Назначение:** Проверяет, есть ли остановка A в списке остановок маршрута
- **Реализация:** Линейный поиск в векторе `allStops`
- **Результат:** `true` если остановка найдена, `false` если нет

### Проверка 2: `route->containsStop(stopB)`
- **Назначение:** Проверяет, есть ли остановка B в списке остановок маршрута
- **Реализация:** Линейный поиск в векторе `allStops`
- **Результат:** `true` если остановка найдена, `false` если нет

### Проверка 3: `route->isStopBefore(stopA, stopB)`
- **Назначение:** Проверяет, что остановка A находится раньше остановки B в последовательности маршрута
- **Реализация:** 
  1. Получить позицию остановки A: `posA = getStopPosition(stopA)`
  2. Получить позицию остановки B: `posB = getStopPosition(stopB)`
  3. Проверить: `posA != -1 && posB != -1 && posA < posB`
- **Результат:** `true` если обе остановки найдены и A находится раньше B, `false` иначе

---

## Особенности алгоритма

1. **Линейная сложность:** O(n × m), где n - количество маршрутов, m - среднее количество остановок в маршруте
2. **Проверка направления:** Алгоритм учитывает направление движения, проверяя, что начальная остановка находится раньше конечной
3. **Возврат всех подходящих маршрутов:** Функция возвращает все маршруты, удовлетворяющие условиям, а не только первый найденный
4. **Использование паттерна Strategy:** Алгоритм реализован через паттерн Strategy, что позволяет легко заменить реализацию

---

## Пример работы

**Входные данные:**
- `stopA = "Центральная площадь"`
- `stopB = "Вокзал"`

**Маршруты в системе:**
- Маршрут 1: ["Центральная площадь", "Парк", "Вокзал", "Аэропорт"]
- Маршрут 2: ["Вокзал", "Центральная площадь", "Парк"]
- Маршрут 3: ["Парк", "Центральная площадь", "Вокзал"]

**Результат:**
- Маршрут 1: ✅ содержит "Центральная площадь", ✅ содержит "Вокзал", ✅ "Центральная площадь" перед "Вокзал" → **ДОБАВЛЕН**
- Маршрут 2: ✅ содержит "Центральная площадь", ✅ содержит "Вокзал", ❌ "Вокзал" перед "Центральная площадь" → **НЕ ДОБАВЛЕН**
- Маршрут 3: ✅ содержит "Центральная площадь", ✅ содержит "Вокзал", ✅ "Центральная площадь" перед "Вокзал" → **ДОБАВЛЕН**

**Итого:** Найдено 2 маршрута (Маршрут 1 и Маршрут 3)


